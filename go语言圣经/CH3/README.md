# 第三章 基础数据类型

Go语言的四类数据结构：基础类型、复合类型、引用类型和接口类型
基础类型:
    数字、字符串、布尔型
复合类型
    数组、结构体
引用类型
    指针、切片、字典、函数、通道

## 3.1 整型

Go语言提供了有符号和无符号类型的整数运算

| | | | |
|-|-|-|-|
|8bit|16bit|32bit|64bit|
|int8|int16|int32(rune)|int64|
|uint8(byte)|uint16|uint32|uint64|

`Unicode字符`,`rune类型`是和int32等价的类型，通常用于标示一个Unicode码点；这两个名称可以互换使用。
`byte`和uint8类型是等价类型为那个，byte类型用于强调数值是一个原始的数据而不是一个小的整数。
`uintptr`是无符号的整数类型，没有指定具体大小，但是足以容纳指针。

* 算数运算符：

`+`、`-`、`*`、`/`、可以适用于整数、浮点数和复数;
取模运算符`%`仅适用于整数间运算；在Go语言中，`%`取模运算符的符号和被取模数的符号总是一致的，`-5%3`和`-5%-3`的结果都是`-2`；
除法运算符`/`的行为则依赖与操作数是否全部为整数，`5.0/4.0 == 5.0/4 == 5/4.0 = 1.25`、但是`5/4=1`；

算术运算符要小心结果溢出，超出的高位bit为将会被丢弃，如果原是数值是有符号的，而且最左边的bit位是1，结果可能是负的
```

// 无符号的uint8，范围[0 ~ 2^8-1]
// 有符号的uint8，范围[-2^7 ~ 2^7-1]
var u uint8 = 255
fmt.Println(u, u+1, u*u)    // 255, 0, 1

var i int8 = 127
fmt.Println(i, i+1, i*i)    // 127, -128, 1
```

* 比较运算符:

`==`、`!=`、`>`、`>=`、`<`、`<=`；比较运算符返回布尔类型。

* 位运算符
`&`：与运算
对应位同时为1才是1，否则为0；例如 00000100 & 00001111 => 00000100

`|`：或运算
对应位只要有一个为1就是1；例如 00000100 & 00001111 => 00001111；

`^`: 
* 一元运算符: 按位取反；例如 ^00010100 => 11101011
* 二元运算符: 异或，对应位相同为0，不同为1；例如 00010100 ^ 00001111 = 00011011

`&^`：位清空
`a &^ b`: 将b中为1的位 对应于a的位清0， a中其他位不变；例如 00010100 &^ 00001111 = 00010000

* `>>`右移和`<<`左移
左移：右边空出的位用 0 填补，高位左移溢出则舍弃该高位; `x<<n`等价于`2^n`；
右移: 无符号的用 0 填充左边空位；有符号的用符号位填，正数用 0，负数用 1

* 一些知识
```
func main() {
	var i uint8 = 20
	fmt.Println(^i, ^20)      // 235 -21
}

原因是 一个是有符号的数，一个是无符号的数
20默认是int类型，最高位是符号位，符号位取反得到的就是复数；

负数的二进制数怎么表示？
负数的二进制数是它对应的正数按位取反得到反码，再加上1得到的补码
例如
3的二进制：     00000000 00000000 00000000 00000011
反码：          11111111 11111111 11111111 11111100
补码：反码加1： 11111111 11111111 11111111 11111101
故-3的二进制为  11111111 11111111 11111111 11111101
```

不同整数类型之间可以通过`T(x)`显示将一个值从一个类型转化为另一种类型。但是对于将一个大的整数类
型转为一个小的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度；

Go语言也提供了无符号数的运算，即使数值本身不可能出现负数，我们还是倾向于使用有符号的`int`类型，就像数组的长度:
```
medals := []string{"gold", "silver", "bronze"}
for i := len(medals) - 1; i >= 0; i-- {
fmt.Println(medals[i]) // "bronze", "silver", "gold"
}
```
如果`len()`函数返回一个无符号数，`i`也是无符号uint类型，那么`i >= 0`则永远为真，当`i == 0`时候，`i--`语句不会是-1，而是`uint`类型的最大值，此时`medals[i]`数组将会越界，程序会panic。

字符面值通过一队`单引号`直接包含对应字符，如ASCII中的'a'写法的字符面值；但是可以通过专一的数值来标示任意的Unicode码点对应的字符；
```
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)   // 97   a   'a'
fmt.Printf("%d %[1]c %[1]q\n", unicode) // 22269 国 '国'
fmt.Printf("%d %[1]q\n", newline)       // 10 '\n'
```

## 3.2 浮点数

Go语言提供了两种精度的浮点数：float32和float64；最大值对应`math.MaxFloat32`和`math.MaxFloat64`；
通常应该`优先使用float64类型`，它提供了更高的精度；
很小很大的数最好用科学计数法书写
```
const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck = 6.62606957e-34 // 普朗克常数
```
可以用`fmt.Printf`函数的`%g`、`%e`、`%f`的形式来打印浮点数；

示例`code/surface/main.go`

## 3.3 复数

Go语言提供了两种精度的复数：complex64和complex128，分别对应float32和float6两种浮点数精度；
`complex`函数用于构建复数，`real`和`image`分别返回复数的实部和虚部
```
var x complex128 = complex(1, 2)    // 1 + 2i 等价于 x := 1 + 2i
var y complex128 = complex(3, 4)    // 3 + 4i
fmt.Println(x*y)                    // (-5+10i)
fmt.Println(real(x*y))              // -5
fmt.Println(imag(x*y))              // 10
```
如果一个浮点数面值或者十进制整数面值后面跟一个i，比如`2i`或者`3.1415i`;它将构成一个复数的虚部，实部为0；
复数可以进行比较，只有两个复数的实部和虚部都相等时候他们才是相等的；
`math/cmplex`包提供了处理复数的函数；

示例`code/mandelbrot/main.go`