# 第二章程序结构

## 2.1 命名
* 必须以字母或者下划线开头，后面可以跟任意数量的字母、数字或下划线
* 大小写字母是不同的变量(区分大小写)
* 关键字不能作为自定义名字，下面是25个关键字

|        |         |        |           |             |
| ---    |  ---    |    --- |   ---     |   ---       |
| break  | default | func   | interface | select      |
| defer  | go      | map    | struct    | else        |
| goto   | package | switch | const     | fallthrough | 
| if     | range   | type   | continue  | for         |
| import | return  | var    | case      | chan        |

* 预定义的名字(对应内建的常量、类型和函数)。这些不是关键字，可以再定义中重新使用(避免过度引起语义混乱)

```
内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex128 complex64
bool byte rune string error

内建函数: make len cap new append copy close delete
complex real imag panic recover
```

* 变量名尽量短小，见名知意
* 推荐使用`驼峰式`命名(parseRequestLine)

## 2.2 声明

Go 程序对应一个或多个以`.go`为文件后缀的源文件中,
每个源文件以包的声明语句开始(`package main`);
`import`可以导入依赖的其他包;
然后是包一级的类型、变量、常量、函数的声明语句;

| 关键字 | 类型 |
|  ---   | ---  |
| var    | 变量 |
| const  | 常量 |
| type   | 声明一种类型 |
| func   | 函数 |

示例`code/boiling/main.go`, `code/ftoc/main.go`

## 2.3 变量

`var 变量名称 类型 = 表达式`;
其中 `类型`或者`= 表达式`2个部分可以省略其中的一个。
省略`类型`；根据初始值表达式推导变量的类型,
省略`= 表达式`；使用类型零值初始化该变量。
类型零值：数值->0、布尔->false、字符串->""、接口或引用(slice/map/chan/函数)->nil;
数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

```
var i, j, k int // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
var f, err = os.Open(name)  // os.Open returns a file and an error
```

### 2.3.1 简短变量声明

`名字 := 表达式`; 变量类型根据表达式来自动推导。
`:=`是一个变量声明语句，`=`是一个变量赋值操作。

简短变量声明也可以用函数的返回值来声明和初始化变量，
```
    f, err := os.Open(name)
```
在`相同的语法域`声明过了，简短变量声明对这些已经声明过的变量只有赋值行为，
```
    in, err := os.Open(inFile)      // 声明了in和err两个变量
    // ...
    out, err := os.Open(outFile)    // 只声明了out一个变量，然后对已声明的err进行赋值操作
```

简短变量声明语句中至少要声明一个新的变量。
简短变量声明只有对已经在`同级语法域`声明的变量才和赋值操作语句等价，如果是`外部语法域`，那么会在当前语法域重新声明一个新变量。

支持多个赋值，
```
i := 100
a, b := true, 1
```

### 2.3.2 指针

* 一个变量对应一个保存了变量对应类型值的内存空间
* 一个指针的值是另一个变量的地址(内存中的存储位置)
* 不是每个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址
* 通过指针可以直接读或者更新对应变量的值，而不需要知道变量的名字
* 变量有时候被称为可寻址的值
* 任何类型的指针零值都是nil
* 指针之间可以进行相等比较，只有指向同一个变量或者都是nil才相等
* 对于聚合类型的每个成员(比如结构体的每个字段、数组的每个元素)也都对应一个变量，可被取地址

`var x int`；`&x`将产生一个指向该整数变量的指针(`p`)，指针对应数据类型`*int`;
`指针p`保存了`x`变量的内存地址，`*p`表达式对应`p指针`指向的变量的值
```
x := 1
p := &x             // *int类型，执行x
fmt.Println(*p)     // "1"
*p = 2              // 等价于 x = 2
fmt.Println(x)      // "2"
```
示例 `code/echo4/main.go`

### 2.3.3 new函数

`new(T)`将创建一个T类型的匿名变量，初始化为T类型的零值，返回返回变量地址，返回的指针类型为`*T`;

### 2.3.4 变量的生命周期

变量的生命周期：程序运行期间变量有效存在的时间间隔。

* 包一级变量，生命周期和整个程序的运行周期是一致的
* 局部变量: 从创建到该变量不再被引用为止，变量的存储空间可能被回收

编译器会自动选择在栈还是堆上分配局部变量的存储空间
```
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    &y = 1
}
```
`f函数`中的`x`变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的`global`变量找到；这个`x`局部变量从`函数f`中逃逸了。

## 2.4 赋值

赋值语句可以更新一个变量的值
```
x = 1                       // 命令变量的赋值
*p = true                   // 通过指针间接赋值
person.Name = "bob"         // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或者map元素赋值
count[x] *= scale           // 简洁形式
x++                         // 自增语句，不是表达式(i = x++ 是错误的)
x--                         // 自减语句
```

### 2.4.1 元组赋值

元组赋值允许同时更新多个变量的值；
赋值之前，赋值语句右边的所有表达式将先进行求值，然后统一更新左边对应变量的值

```
// 2个变量的交换
x, y = y, x     
a[i], a[j] = a[j], a[i]

// 获取两个整数值的最大公约数
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}

// 计算斐波那契数列的第N个数
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y
    }
    return x;
}

// 元组赋值也可以使一系列琐碎赋值更加紧凑
i, j, k = 2, 3, 5
```

### 2.4.2 可赋值性

赋值语句是显式的赋值形式；
程序大部分也会发生隐式赋值：
函数调用会隐式将参数赋值给函数的形参，返回语句将隐式地将返回值赋值给结果变量，
符合类型的字面量也会发生赋值行为，比如:

```
medals := []string{"gold", "silver", "bronze"}
// 上面隐式地对slice的每个元素进行赋值操作，类似：
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "golbronzed"
```
可赋值性的规则：类型必须完全匹配，nil可以赋值给任何指针或者引用类型的变量；
`==`或者`!=`比较的能力也和可赋值能力有关系，相比较的第二个值必须对一个值类型对应的变量是可赋值的

## 2.5 类型

`type 类型名称 底层类型`
类型声明语句创建了一个新的`类型名称`，和`底层类型`具有相同的底层结构；
新类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的

示例`code/tempconv0/main.go`
// Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。
// 类型转换不会改变值本身，但是会使它们的语义发生变化

对于每个类型`T`，都有一个对应的类型转换操作`T(x)`,用于将`x`转换为`T`类型，
如果`T`是指针类型，可能会需要小括号包装T，比如(*int)(0)；
只有两个类型的底层基础类型相同，或者都是指向相同底层结构的指针类型，才允许转换操作；
转换只改变类型而不会影响本身。
```
// 接 code/tempconv0/main.go
var c Celsius
var f Fahrenheit
fmt.Println(c == 0)             // "true"
fmt.Println(f >= 0)             // "true"
fmt.Println(c == f)             // compile error: type mismatch
fmt.Println(c == Celsius(f))    // "true"! 类型转换，不改变值。都是零值所以相等
```

## 2.6 包和文件

引入包的概念是为了支持模块化、分装、单独编译和代码重用；
每个包都对应一个独立的名字空间，一个包可以包含多个`.go`源文件；
包可以通过大小写控制变量是外部可见的，用来隐藏内部实现，大写可导出，小写隐藏不可导出；
示例: `code/tempconv` (这里使用了`go mod`命令: go mod init 'github.com/read-books/tempconv')

### 2.6.1 导入包

每个包都有全局唯一的道导入路径；
除了包的导入路径，每个包还有一个包名，包名不要求唯一；
按照惯例，包的名字和包的导入路径的最后一个字段相同；
导入不使用的包，无法通过编译；
示例: `code/cf/main.go` (这里使用了`go mod`命令: go mod init 'github.com/read-books/cf')

### 2.6.2 包的初始化

包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化

```
var a = b + c       // a 第三个初始化，为3
var b = f()         // b 第二个初始化, 为2
var c = 1           // c 第一个初始化

func f() int {return c + 1}
```

多个`.go`源文件，构建工具会根据文件名排序，然后依次调用编译器编译;
`init`函数:不能被调用或者引用，每个文件的`init`初始化函数，在程序开始执行时候按照它们声明的顺序被自动调用；
每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会初始化一次；
初始化工作是自下而上进行的，main包最后被初始化；

示例练习: `code/popcount/main.go`，测试代码`code/popcount/main_test.go`

## 2.7 作用域

作用域和生命周期不同:
作用域：一个源代码的文本区域，编译时的属性，
生命周期: 程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用，是运行时的概念；

语法块是有花括号包含的一系列语句，就像函数体或者循环花括号对应的语法块那样。
语法块内部声明是无法被外部语法块访问的。
语法块决定了其内部声明的名字的作用域范围。
一个程序可能包含多个同名的声明，只要它们在不同的语法区域就没关系。

当编译器遇到一个名字引用时，首先从最内层语法域向全局作用域查找，如果没有找到就报错；
如果该名字在内部和外部分别声明过，内部块的声明先被找到，内部声明就屏蔽了外部同名的声明。